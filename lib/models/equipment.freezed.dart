// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'equipment.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

EquipmentStats _$EquipmentStatsFromJson(Map<String, dynamic> json) {
  return _EquipmentStats.fromJson(json);
}

/// @nodoc
mixin _$EquipmentStats {
  int get str => throw _privateConstructorUsedError; // Strength
  int get intel => throw _privateConstructorUsedError; // Intelligence
  int get spd => throw _privateConstructorUsedError; // Speed
  int get wil => throw _privateConstructorUsedError; // Willpower
  int get nin => throw _privateConstructorUsedError; // Ninjutsu
  int get gen => throw _privateConstructorUsedError; // Genjutsu
  int get buki => throw _privateConstructorUsedError; // Bukijutsu
  int get tai => throw _privateConstructorUsedError; // Taijutsu
  int get hp => throw _privateConstructorUsedError; // extra HP max
  int get sp => throw _privateConstructorUsedError; // extra Stamina max
  int get cp => throw _privateConstructorUsedError;

  /// Serializes this EquipmentStats to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of EquipmentStats
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $EquipmentStatsCopyWith<EquipmentStats> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EquipmentStatsCopyWith<$Res> {
  factory $EquipmentStatsCopyWith(
          EquipmentStats value, $Res Function(EquipmentStats) then) =
      _$EquipmentStatsCopyWithImpl<$Res, EquipmentStats>;
  @useResult
  $Res call(
      {int str,
      int intel,
      int spd,
      int wil,
      int nin,
      int gen,
      int buki,
      int tai,
      int hp,
      int sp,
      int cp});
}

/// @nodoc
class _$EquipmentStatsCopyWithImpl<$Res, $Val extends EquipmentStats>
    implements $EquipmentStatsCopyWith<$Res> {
  _$EquipmentStatsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of EquipmentStats
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? str = null,
    Object? intel = null,
    Object? spd = null,
    Object? wil = null,
    Object? nin = null,
    Object? gen = null,
    Object? buki = null,
    Object? tai = null,
    Object? hp = null,
    Object? sp = null,
    Object? cp = null,
  }) {
    return _then(_value.copyWith(
      str: null == str
          ? _value.str
          : str // ignore: cast_nullable_to_non_nullable
              as int,
      intel: null == intel
          ? _value.intel
          : intel // ignore: cast_nullable_to_non_nullable
              as int,
      spd: null == spd
          ? _value.spd
          : spd // ignore: cast_nullable_to_non_nullable
              as int,
      wil: null == wil
          ? _value.wil
          : wil // ignore: cast_nullable_to_non_nullable
              as int,
      nin: null == nin
          ? _value.nin
          : nin // ignore: cast_nullable_to_non_nullable
              as int,
      gen: null == gen
          ? _value.gen
          : gen // ignore: cast_nullable_to_non_nullable
              as int,
      buki: null == buki
          ? _value.buki
          : buki // ignore: cast_nullable_to_non_nullable
              as int,
      tai: null == tai
          ? _value.tai
          : tai // ignore: cast_nullable_to_non_nullable
              as int,
      hp: null == hp
          ? _value.hp
          : hp // ignore: cast_nullable_to_non_nullable
              as int,
      sp: null == sp
          ? _value.sp
          : sp // ignore: cast_nullable_to_non_nullable
              as int,
      cp: null == cp
          ? _value.cp
          : cp // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EquipmentStatsImplCopyWith<$Res>
    implements $EquipmentStatsCopyWith<$Res> {
  factory _$$EquipmentStatsImplCopyWith(_$EquipmentStatsImpl value,
          $Res Function(_$EquipmentStatsImpl) then) =
      __$$EquipmentStatsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int str,
      int intel,
      int spd,
      int wil,
      int nin,
      int gen,
      int buki,
      int tai,
      int hp,
      int sp,
      int cp});
}

/// @nodoc
class __$$EquipmentStatsImplCopyWithImpl<$Res>
    extends _$EquipmentStatsCopyWithImpl<$Res, _$EquipmentStatsImpl>
    implements _$$EquipmentStatsImplCopyWith<$Res> {
  __$$EquipmentStatsImplCopyWithImpl(
      _$EquipmentStatsImpl _value, $Res Function(_$EquipmentStatsImpl) _then)
      : super(_value, _then);

  /// Create a copy of EquipmentStats
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? str = null,
    Object? intel = null,
    Object? spd = null,
    Object? wil = null,
    Object? nin = null,
    Object? gen = null,
    Object? buki = null,
    Object? tai = null,
    Object? hp = null,
    Object? sp = null,
    Object? cp = null,
  }) {
    return _then(_$EquipmentStatsImpl(
      str: null == str
          ? _value.str
          : str // ignore: cast_nullable_to_non_nullable
              as int,
      intel: null == intel
          ? _value.intel
          : intel // ignore: cast_nullable_to_non_nullable
              as int,
      spd: null == spd
          ? _value.spd
          : spd // ignore: cast_nullable_to_non_nullable
              as int,
      wil: null == wil
          ? _value.wil
          : wil // ignore: cast_nullable_to_non_nullable
              as int,
      nin: null == nin
          ? _value.nin
          : nin // ignore: cast_nullable_to_non_nullable
              as int,
      gen: null == gen
          ? _value.gen
          : gen // ignore: cast_nullable_to_non_nullable
              as int,
      buki: null == buki
          ? _value.buki
          : buki // ignore: cast_nullable_to_non_nullable
              as int,
      tai: null == tai
          ? _value.tai
          : tai // ignore: cast_nullable_to_non_nullable
              as int,
      hp: null == hp
          ? _value.hp
          : hp // ignore: cast_nullable_to_non_nullable
              as int,
      sp: null == sp
          ? _value.sp
          : sp // ignore: cast_nullable_to_non_nullable
              as int,
      cp: null == cp
          ? _value.cp
          : cp // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EquipmentStatsImpl implements _EquipmentStats {
  const _$EquipmentStatsImpl(
      {this.str = 0,
      this.intel = 0,
      this.spd = 0,
      this.wil = 0,
      this.nin = 0,
      this.gen = 0,
      this.buki = 0,
      this.tai = 0,
      this.hp = 0,
      this.sp = 0,
      this.cp = 0});

  factory _$EquipmentStatsImpl.fromJson(Map<String, dynamic> json) =>
      _$$EquipmentStatsImplFromJson(json);

  @override
  @JsonKey()
  final int str;
// Strength
  @override
  @JsonKey()
  final int intel;
// Intelligence
  @override
  @JsonKey()
  final int spd;
// Speed
  @override
  @JsonKey()
  final int wil;
// Willpower
  @override
  @JsonKey()
  final int nin;
// Ninjutsu
  @override
  @JsonKey()
  final int gen;
// Genjutsu
  @override
  @JsonKey()
  final int buki;
// Bukijutsu
  @override
  @JsonKey()
  final int tai;
// Taijutsu
  @override
  @JsonKey()
  final int hp;
// extra HP max
  @override
  @JsonKey()
  final int sp;
// extra Stamina max
  @override
  @JsonKey()
  final int cp;

  @override
  String toString() {
    return 'EquipmentStats(str: $str, intel: $intel, spd: $spd, wil: $wil, nin: $nin, gen: $gen, buki: $buki, tai: $tai, hp: $hp, sp: $sp, cp: $cp)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EquipmentStatsImpl &&
            (identical(other.str, str) || other.str == str) &&
            (identical(other.intel, intel) || other.intel == intel) &&
            (identical(other.spd, spd) || other.spd == spd) &&
            (identical(other.wil, wil) || other.wil == wil) &&
            (identical(other.nin, nin) || other.nin == nin) &&
            (identical(other.gen, gen) || other.gen == gen) &&
            (identical(other.buki, buki) || other.buki == buki) &&
            (identical(other.tai, tai) || other.tai == tai) &&
            (identical(other.hp, hp) || other.hp == hp) &&
            (identical(other.sp, sp) || other.sp == sp) &&
            (identical(other.cp, cp) || other.cp == cp));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, str, intel, spd, wil, nin, gen, buki, tai, hp, sp, cp);

  /// Create a copy of EquipmentStats
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$EquipmentStatsImplCopyWith<_$EquipmentStatsImpl> get copyWith =>
      __$$EquipmentStatsImplCopyWithImpl<_$EquipmentStatsImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EquipmentStatsImplToJson(
      this,
    );
  }
}

abstract class _EquipmentStats implements EquipmentStats {
  const factory _EquipmentStats(
      {final int str,
      final int intel,
      final int spd,
      final int wil,
      final int nin,
      final int gen,
      final int buki,
      final int tai,
      final int hp,
      final int sp,
      final int cp}) = _$EquipmentStatsImpl;

  factory _EquipmentStats.fromJson(Map<String, dynamic> json) =
      _$EquipmentStatsImpl.fromJson;

  @override
  int get str; // Strength
  @override
  int get intel; // Intelligence
  @override
  int get spd; // Speed
  @override
  int get wil; // Willpower
  @override
  int get nin; // Ninjutsu
  @override
  int get gen; // Genjutsu
  @override
  int get buki; // Bukijutsu
  @override
  int get tai; // Taijutsu
  @override
  int get hp; // extra HP max
  @override
  int get sp; // extra Stamina max
  @override
  int get cp;

  /// Create a copy of EquipmentStats
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$EquipmentStatsImplCopyWith<_$EquipmentStatsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

EquippableMeta _$EquippableMetaFromJson(Map<String, dynamic> json) {
  return _EquippableMeta.fromJson(json);
}

/// @nodoc
mixin _$EquippableMeta {
  Set<SlotType> get allowedSlots =>
      throw _privateConstructorUsedError; // Which slots this item can go into
  bool get twoHanded =>
      throw _privateConstructorUsedError; // If true and equipped in one arm, occupies both hands
  EquipmentStats get bonuses =>
      throw _privateConstructorUsedError; // Stat bonuses granted while equipped
  int get waistCapacity =>
      throw _privateConstructorUsedError; // If this item is worn in WAIST, how many **small** items can be stored
  ItemSize get size => throw _privateConstructorUsedError;

  /// Serializes this EquippableMeta to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of EquippableMeta
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $EquippableMetaCopyWith<EquippableMeta> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EquippableMetaCopyWith<$Res> {
  factory $EquippableMetaCopyWith(
          EquippableMeta value, $Res Function(EquippableMeta) then) =
      _$EquippableMetaCopyWithImpl<$Res, EquippableMeta>;
  @useResult
  $Res call(
      {Set<SlotType> allowedSlots,
      bool twoHanded,
      EquipmentStats bonuses,
      int waistCapacity,
      ItemSize size});

  $EquipmentStatsCopyWith<$Res> get bonuses;
}

/// @nodoc
class _$EquippableMetaCopyWithImpl<$Res, $Val extends EquippableMeta>
    implements $EquippableMetaCopyWith<$Res> {
  _$EquippableMetaCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of EquippableMeta
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? allowedSlots = null,
    Object? twoHanded = null,
    Object? bonuses = null,
    Object? waistCapacity = null,
    Object? size = null,
  }) {
    return _then(_value.copyWith(
      allowedSlots: null == allowedSlots
          ? _value.allowedSlots
          : allowedSlots // ignore: cast_nullable_to_non_nullable
              as Set<SlotType>,
      twoHanded: null == twoHanded
          ? _value.twoHanded
          : twoHanded // ignore: cast_nullable_to_non_nullable
              as bool,
      bonuses: null == bonuses
          ? _value.bonuses
          : bonuses // ignore: cast_nullable_to_non_nullable
              as EquipmentStats,
      waistCapacity: null == waistCapacity
          ? _value.waistCapacity
          : waistCapacity // ignore: cast_nullable_to_non_nullable
              as int,
      size: null == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as ItemSize,
    ) as $Val);
  }

  /// Create a copy of EquippableMeta
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $EquipmentStatsCopyWith<$Res> get bonuses {
    return $EquipmentStatsCopyWith<$Res>(_value.bonuses, (value) {
      return _then(_value.copyWith(bonuses: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$EquippableMetaImplCopyWith<$Res>
    implements $EquippableMetaCopyWith<$Res> {
  factory _$$EquippableMetaImplCopyWith(_$EquippableMetaImpl value,
          $Res Function(_$EquippableMetaImpl) then) =
      __$$EquippableMetaImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Set<SlotType> allowedSlots,
      bool twoHanded,
      EquipmentStats bonuses,
      int waistCapacity,
      ItemSize size});

  @override
  $EquipmentStatsCopyWith<$Res> get bonuses;
}

/// @nodoc
class __$$EquippableMetaImplCopyWithImpl<$Res>
    extends _$EquippableMetaCopyWithImpl<$Res, _$EquippableMetaImpl>
    implements _$$EquippableMetaImplCopyWith<$Res> {
  __$$EquippableMetaImplCopyWithImpl(
      _$EquippableMetaImpl _value, $Res Function(_$EquippableMetaImpl) _then)
      : super(_value, _then);

  /// Create a copy of EquippableMeta
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? allowedSlots = null,
    Object? twoHanded = null,
    Object? bonuses = null,
    Object? waistCapacity = null,
    Object? size = null,
  }) {
    return _then(_$EquippableMetaImpl(
      allowedSlots: null == allowedSlots
          ? _value._allowedSlots
          : allowedSlots // ignore: cast_nullable_to_non_nullable
              as Set<SlotType>,
      twoHanded: null == twoHanded
          ? _value.twoHanded
          : twoHanded // ignore: cast_nullable_to_non_nullable
              as bool,
      bonuses: null == bonuses
          ? _value.bonuses
          : bonuses // ignore: cast_nullable_to_non_nullable
              as EquipmentStats,
      waistCapacity: null == waistCapacity
          ? _value.waistCapacity
          : waistCapacity // ignore: cast_nullable_to_non_nullable
              as int,
      size: null == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as ItemSize,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EquippableMetaImpl implements _EquippableMeta {
  const _$EquippableMetaImpl(
      {required final Set<SlotType> allowedSlots,
      this.twoHanded = false,
      this.bonuses = const EquipmentStats(),
      this.waistCapacity = 0,
      this.size = ItemSize.normal})
      : _allowedSlots = allowedSlots;

  factory _$EquippableMetaImpl.fromJson(Map<String, dynamic> json) =>
      _$$EquippableMetaImplFromJson(json);

  final Set<SlotType> _allowedSlots;
  @override
  Set<SlotType> get allowedSlots {
    if (_allowedSlots is EqualUnmodifiableSetView) return _allowedSlots;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_allowedSlots);
  }

// Which slots this item can go into
  @override
  @JsonKey()
  final bool twoHanded;
// If true and equipped in one arm, occupies both hands
  @override
  @JsonKey()
  final EquipmentStats bonuses;
// Stat bonuses granted while equipped
  @override
  @JsonKey()
  final int waistCapacity;
// If this item is worn in WAIST, how many **small** items can be stored
  @override
  @JsonKey()
  final ItemSize size;

  @override
  String toString() {
    return 'EquippableMeta(allowedSlots: $allowedSlots, twoHanded: $twoHanded, bonuses: $bonuses, waistCapacity: $waistCapacity, size: $size)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EquippableMetaImpl &&
            const DeepCollectionEquality()
                .equals(other._allowedSlots, _allowedSlots) &&
            (identical(other.twoHanded, twoHanded) ||
                other.twoHanded == twoHanded) &&
            (identical(other.bonuses, bonuses) || other.bonuses == bonuses) &&
            (identical(other.waistCapacity, waistCapacity) ||
                other.waistCapacity == waistCapacity) &&
            (identical(other.size, size) || other.size == size));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_allowedSlots),
      twoHanded,
      bonuses,
      waistCapacity,
      size);

  /// Create a copy of EquippableMeta
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$EquippableMetaImplCopyWith<_$EquippableMetaImpl> get copyWith =>
      __$$EquippableMetaImplCopyWithImpl<_$EquippableMetaImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EquippableMetaImplToJson(
      this,
    );
  }
}

abstract class _EquippableMeta implements EquippableMeta {
  const factory _EquippableMeta(
      {required final Set<SlotType> allowedSlots,
      final bool twoHanded,
      final EquipmentStats bonuses,
      final int waistCapacity,
      final ItemSize size}) = _$EquippableMetaImpl;

  factory _EquippableMeta.fromJson(Map<String, dynamic> json) =
      _$EquippableMetaImpl.fromJson;

  @override
  Set<SlotType> get allowedSlots; // Which slots this item can go into
  @override
  bool get twoHanded; // If true and equipped in one arm, occupies both hands
  @override
  EquipmentStats get bonuses; // Stat bonuses granted while equipped
  @override
  int get waistCapacity; // If this item is worn in WAIST, how many **small** items can be stored
  @override
  ItemSize get size;

  /// Create a copy of EquippableMeta
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$EquippableMetaImplCopyWith<_$EquippableMetaImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
